I’ve been coding for a little over three years. I’ve spent a lot of that time questioning my choice to pursue a career in this field, doubting my ability to learn to code, wondering if this was really what I wanted to do, seeking answer to the ultimate question: Can I do it?

None of this has gone away. I still need reassurance that I’m doing ok, that it’s fine if I’m taking a while with a task, that I actually know enough because, really, I cannot know everything. But there are still days when I want to drop everything and move to Scotland to become a landscape photographer or a lifestyle blogger because coding seems impossible. There are still days when I forget that nothing worth doing comes easily, there are still days when I’m convinced I’m a fraud and that people are just waiting to fire me.

There are days when I feel I take too long to do something. There are days where I feel I’m doing things that work but that are in fact completely wrong. There are days where I think I’m so stupid for not knowing everything about the concepts and ideas I’m literally using in my code on that day. There are days where I’m convinced that because I don’t code when I’m at home I’m not really a developer.

There are days when all I can believe is that I’m lazy and will never learn properly or understand anything. When the only thing that keeps me going is fear. The fear that as a woman in a technical role, I’ll look weak and incapable if I give up, and that I’ll end up being the very image of what I’m trying to fight. The fear to hear that “women can’t code”. The fear that all that time I have invested in learning to code will have been a waste. The fear that there is nothing out there that I can do. The fear to let myself down. The fear to look like a failure to my friends and family.

But I have fewer of these days than I used to. Little by little, I’ve learned what works for me. I’ve learned that if I code all the time I burn out. I’ve learned that these other hobbies of mine make me a better developer because it creates different connections that help me solve more problems in more creative ways. I’ve learned to be kinder to myself, to ask for help, I’ve learned when to stop, when to spend more time on a problem, and a myriad other things you only figure out when you’re learning.

Some challenges I’ve conquered already, some I’m still facing. Some were minor, others felt insurmountable, and while I’m not always certain if it’s fear or determination that keeps me going, I’m grateful I’m still programming. I’m grateful I haven’t given up yet. I’m grateful I’m still learning.

Because programming is hard. No, really, it is. You’ll hear people equating it to learning a foreign language, and while there are similarities, there’s a very glaring difference we all conveniently forget to mention: computers are incapable of inferring meaning. The world of computers is black and white, something either works or it doesn’t. The way you’ve expressed your idea to the computer may be great, or it may be mediocre, but at the end of the end, you program runs or it doesn’t. Humans, on the other hand, may take a few seconds before understanding someone else, but they’re much more forgiving. “Restaurant — where?” makes sense. It’s understandable, even if incomplete or inaccurate. You might have to spell out “Montmartre”, or “Leicester Square” but you’ll probably get there.

But when you decide to write code, you’re in a completely different ballpark. You have to ignore decades of deeply-ingrained habits, of pattern-matching, of extrapolating, or of finding meaning, and instead bend your thoughts to a much, much stricter set of rules. You need to be precise, for a missing colon or bracket will result in an error. If you use the wrong type, or the wrong equality operator, or someone cruelly replaced your semi colon with a Greek question mark, all you will be told is that there is something wrong and you need to fix it.

You need to retrain your brain to use logic in a way you may not have needed to until now. You need to start thinking in conditionals and loops, and figure out ways to make your real-life problem fit the narrow set of actions a computer possesses. On top of that, you’re constantly exposed to everything you don’t know yet. All that ocean of knowledge, in which it’s so very easy to feel like you’re drowning. All those best practices you worry about, all these IDEs and editors with their special shortcuts, all the tools and libraries and frameworks that are part of the ecosystem of the one language you’re currently learning.

Programming is hard. It’s so very easy to feel lost, out of depth, inept, stupid. It’s so very easy to think that you’re not cut out for it, that you can’t do it, that you’re not smart enough, that others just get it and that you don’t. It’s so very easy to feel like an impostor, like you shouldn’t be where you are, that the bootcamp or degree programme that took you on made a mistake, that your employer will discover you’re a fraud very soon, that you’ll never make it.

None of this is true. At least insofar as everyone else also feels that way. If you care enough that you have all these thoughts crowding your mind when you’re faced with a tough programming problem, then you can do it. Forget about what you do not know yet. Forget about your unrealistic expectations, forget about your perfectionism, forget about the pig picture, forget about what you want your programme to look like. Let’s just give it a try together, shall we?

I’m hoping to share a few strategies here that have helped me so that a) they can help you too, and b) I have a repository of them when I inevitably end up in my pit of despair and it’s somehow got a little bit deeper than the last time I was in it.

Obviously, as a human being, I’m not perfect. I’ve had my fair share of unpleasant experiences that have shaped my self-beliefs, and the years of bullying at the hands of teachers telling me I’d never make it are still haunting me. Most of my friends would also probably tell you I’m high-strung, intense, hyper and that I need to chill the F out because the truckloads of anxious thoughts I come up with per second help no-one, and certainly not me. I also went to therapy to try and curb my perfectionism because it was literally stopping me from doing my work.

So there, don’t worry, you’re not alone.

First, let me look at a couple of things that are possible reasons you’re feeling this self-doubt (there are so many more, but I’m no psychologist and this is an article about potential solutions, not causes!):

Impostor’s syndrome: If you’ve ever felt that you didn’t deserve to be where you are, that you discount your achievements based on luck, knowing the right person, being in the right place at the right time, and most importantly, you live in constant fear that people are going to “figure you out” and realise that you’re a fraud, you could be suffering from the all-too-common impostor’s syndrome. People in tech seem to very prone to it, and women especially are victims of it (this long read from The Atlantic is a fascinating insight into what it’s like to be a working woman.)
Learned helplessness: This is a behaviour that has been researched by Martin Seligman, who conducted pretty shitty experiments on dogs, zapping them with electricity while they were in environments where nothing they could do could change the zapping. The dogs would end up bracing for the shock, and not even try to escape anymore. I’ll invite you to read this eloquent New Yorker article on the topic to gain a better understanding of the effect on humans, but essentially, if your resilience (the way you bounce back from adversity) isn’t great, you might stop trying because trying feels like it doesn’t change anything.
I definitely fall into the second category, if you were wondering, but really, what we want to focus on here is how to curb self-doubt, and especially self-doubt when it comes to programming. And oh boy are we in for a ride.

I — Self-compassion
I’ve briefly touched on it in my previous story, but I genuinely believe that self-compassion is a key component to accepting yourself as you are, mistakes and failures and rejections included. Self-compassion helps reduce feelings of guilt and shame when we do something wrong. It helps us connect with others and see that we’re all similar, we all mess up and no-one is truly perfect. It helps us see past the curtain of perfection, and helps us appreciate all our oddities and real life bloopers.

So how do you practice self-compassion? By reframing your thoughts. Now let me preface this by saying that reframing your thoughts is even harder than programming, because your brain is a bloody rock that refuses to acknowledge anything that might be better for you when you’ve being doing something for a long enough period of time. Kristen Neff has done a lot of research on self-compassion, and has put together some great resources. She has an audiobook of guided meditations and a workbook to help you practice it, but if you want some more immediate resources, check out her page.

In your everyday life as a coder, self-compassion will help you be less frustrated at the silly mistakes you make, or the fact that you don’t know something when everyone else seems to know it. It will reduce the amount of negative chatter that goes on in your head that slows you down or makes you doubt your abilities. That way you can keep going.

II — Reframing your thoughts
I just talked about it, but it warrants its own section because it’s such a powerful and often under-utilised tool. Reframing your thoughts involves identifying the negative thought that you’re having, thinking about why that thought has popped up in your mind, looking objectively at that thought and then reframing it in a more objective manner. It’s a common Cognitive-Behavioural Therapy technique, and a useful one at that, but it take a while to internalise, it’s a very involved process and it’s not always comfortable to follow. I practice best with this record sheet, which as you can see, isn’t small. For more detailed instructions, head on over to this site. This is something that you have to make a conscious effort to do, but regular practice will help you make it a habit.

On a daily basis, this allows you to challenge your thoughts both negative and positive. You will be able to stop thinking you’re an idiot for not spotting that missing curly bracket in your JSON test file, and you may also start looking at other angles for your problems because your lil’ neurons are now used to questioning reality.

III — Mindfulness
Uuurgh, no, I’m not into all this new age yoga stuff, I hear you say. Well yeah ok, but you don’t have to do any yoga, or meditation to practice mindfulness. In a world where everything and everyone travels at a million miles per hour and our brains are constantly active, mindfulness is just about stopping and appreciating the moment. Have you ever eaten biscuits and when you went to get another one realised that the packet was empty, but you didn’t remember eating them? Practicing mindfulness can be as simple as focusing on that biscuit, the layers it’s made of, the delicious taste of it, the smell, and the crumbs it leaves on your fingers.

Practicing mindfulness when you’re programming will allow you to slow the stream of anxious thoughts you may have that ultimately slow you down. Taking it 10 seconds at a time the way Kimmy Schmidt does keeps you focused on what you’re currently doing, rather than thinking about the hundreds of other spatiotemporal continuums in which you’re a janitor, or a Greek god, or a rockstar. Just focus on that one test you need to write, you’ll worry about the next one later. You don’t need to think about that potential feature just yet, leave it alone.

IV — Mindset
Mindset is one of my favourite books of all times. It was written by Carol Dweck, who has dedicated her life to researching what mindset is and how it works. I urge you to go read her book to enjoy the full experience, but until then, what I will mention is that her thesis relies on the tenet that people have a growth mindset or a fixed mindset. A fixed mindset means people see intelligence and traits as fixed and immutable. This will result in people being less likely to question things, or try them out, or accept failure as something that is just a stepping stone and can be built on. People with a growth mindset, on the other hand, believe that their learning and intelligence can grow with time and experience. They are less afraid to make mistakes, and they spend more time practicing because they understand that this will help them in the long run.

Developing a growth mindset is crucial when you want to work as a developer. Understanding that you always have something new to learn, that you need to practice to improve your skills, that there is no end to your learning in this field will get you so much further than someone who doesn’t believe they will get better at coding, or is looking for a finite amount of programming knowledge (good luck!)

V — Asking for help
Asking for help is difficult. We’re worried about looking incompetent, about asking stupid questions, about taking up people’s time. But leave your ego aside for a second, because asking that question that’s been bothering you for hours and that you can’t get an answer to will probably help you get unblocked. You’ll be able to make progress and feel less frustrated, and you will have identified a pain point that you can keep for later to work on.

If you want to be an effective programmer, you need to learn to ask for help. From colleagues, or friends, or people on the Internet, just swallow down the pride that’s telling you that if you keep at it you’ll figure it out, save yourself some pain and enjoy the knowledge that will flow your way. As a general rule, you should not hesitate to seek help after you’ve been stuck on a problem for 30min or more.

VI — Breaking down problems
Oh hey, Captain Obvious! I’m sure you already know about the strange and dark art of breaking your problem down. A difficult practice that requires training and a little sweat, tears and blood (ish), but that gets easier with time and experience. When we code, problems come to us fully formed. Say, the client wants a new field in a form that appears on the front page.

Oh cool, that’s easy, you think to yourself, I just need to add it to the page, then in the database and sort- oh wait, what? This isn’t a regular field, it goes in a different place that has not been touched for years! Now your problem is to effectively recreate every item in the database, with a bunch of them shifted by one to accommodate the new question. Plus you’ll need to update the CSS because the page it should appear on has a slightly different colour scheme, and of course, the font needs to be different from the other questions. Oh boy, now your problem has increased ten-fold and you don’t know where to start.

Well, if you start by trying to explain your problem to someone else, you will be able to figure out some of the main components your problem is made of. Here, I have to play around with the database, and I know it involves doing a migration (or 88, if you were me in May). I also know I’ll need to add the question to the page, so I guess I’ll need to update the HTML for it. Because it’s linked to the back end, I might need to re-jig the page so that the backend takes a new field, depending on how mangled the codebase is. And then you know there’s some CSS that needs to be taken care of. So there, you have 4 smaller chunks waiting for you.

Now of course, you can break down those chunks even further. When I look at the database migration I need to run, it looks like I might need a command, rather than a regular migration. That means I don’t have to worry about the downgrade, because I will only make that change once. Then I need to think about what exactly it is that I need to do in that migration. I need to gather all the fields, insert a new one, and repopulate my database with the fields in the correct order. And now I have a clearer idea of where I can start.

When in doubt, grab someone to explain the problem to, or someone to help brainstorm how you break down that problem. It’s always interesting to see how different people would go on about solving the same problem, and it may give you more ideas for your implementation.

These things have all helped me reduce my self-doubt and have made me a better person and developer. They’ve helped me become more objective about myself and my abilities, and kinder towards myself and others. I worry less about myself, and can use that newfound bandwidth to focus on my work instead.

Of course, sometimes I have lapses. I’ve just started minimax in Java, and the experience was so painful in Clojure that I’ve already spent an entire day worrying about how long it would take me, and thinking about how stupid I am that I can’t figure it out, and crying about it all in the toilets while wondering to myself why I shouldn’t move to Scotland to breed sheep instead of having to implement an… algorithm *shudders*. But a little pairing helped me get started, and having broken down my problem further and into smaller chunks, I can focus on those instead, which worries me far less than THE WHOLE OF MINIMAX.

And you know, sometimes it’s ok to have a meh day. But get yourself a glass of your favourite poison once you’re home, or have a chat with your friends, practice self-compassion, reframe your thoughts, light up some candles and have a bubbled bath to take care of yourself until you feel stronger. Just remember that this too shall pass!

P.S.: If you’ve made it this far, go get another cuppa. You deserve it!
